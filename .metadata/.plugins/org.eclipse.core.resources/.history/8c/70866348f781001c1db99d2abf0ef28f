package york.eecs.test;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import york.eecs.source.UndirectedGraph;
import york.eecs.source.UndirectedGraphAlgorithms;
import york.eecs.source.VertexExistsException;

public class StudentTest {

	 /**
	  * TODO: Please write at least 5 test cases for testing @UndirectedGraph.
	  * TODO: Please write at least 5 test cases for testing @UndirectedGraphAlgorithms.
	  */
	
	UndirectedGraphAlgorithms<String> uga;
	@Before
	public void setUp() throws Exception {
		uga = new UndirectedGraphAlgorithms<>();
	}
	
	 ///////////////////////////
	////UndirectGraph Tests////
   ///////////////////////////
	
	@Test
	public void graphEmptyTest()
	{
		//testing whether an empty graph returns the right boolean value
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		boolean result = ug.isEmpty();
		boolean expected = false;
		assertEquals(result, expected);
	}
	
	@Test
	public void graphEmptySizeTest()
	{
		//testing whether an empty graph returns 0 as it's size
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		int result = ug.getSize();
		int expected = 0;
		assertEquals(result, expected);
	}
	
	@Test
	public void graphEmptyStringTest()
	{
		//testing the string an empty graph returns
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		String result = ug.toString();
		String expected = "Graph:\n";
		assertEquals(result, expected);
	}
	
	@Test
	public void getEmptyVerticesTest()
	{
		//testing the number of vertices that an empty graph returns
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		List<String> result = ug.getVertices();
		List<String> expected = new ArrayList<>();
		assertEquals(result, expected);
	}
	
	@Test
	public void graphVertexExistsTest()
	{
		//testing what is returned if an existing vertex is inserted
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		boolean vertexExceptionThrown =  false;
		try 
		{
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
			ug.addEdge("A", "B");
			ug.addEdge("A", "C");
			ug.addVertex("A");
		}
		catch (VertexExistsException e) 
		{
			vertexExceptionThrown =  true;
		}
		assertTrue(vertexExceptionThrown);
	}
	 
	@Test
	public void graphNoEdgeTest()
	{
		//testing what happens if we have no vertices in the graph, but
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
	}
	
	 ///////////////////////////////////////
	////UndirectedGraphAlgorithms Tests////
   ///////////////////////////////////////
	
	@Test(expected = NullPointerException.class)
	public void algorithmEmptyTest()
	{
		//testing what is returned if the graph is empty
		//here we expect a NullPointerException
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "B", "C");
	}
	
	@Test
	public void algorithmNoEdgeTest()
	{
		//testing for if there are no edges between the vertices in the graph
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		try 
		{
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
		}
		catch(VertexExistsException e)
		{
			e.printStackTrace();
		}
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "B", "C");
		List<String> expected = new ArrayList<String>();
		assertEquals(result, expected);
	}
	
	@Test
	public void algorithmDisconnectedEdgeTest()
	{
		//testing for if the destination edge is disconnected from the starting edge
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		try 
		{
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
			ug.addEdge("A", "B");
		}
		catch(VertexExistsException e)
		{
			e.printStackTrace();
		}
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "B", "C");
		List<String> expected = new ArrayList<String>();
		assertEquals(result, expected);
	}
	
	@Test(expected = NullPointerException.class)
	public void algorithmStartDoesNotExistTest()
	{
		//testing what is returned if the starting node does not exist
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		try 
		{
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
			ug.addEdge("A", "B");
		}
		catch(VertexExistsException e)
		{
			e.printStackTrace();
		}
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "E", "C");
	}
	
	@Test
	public void algortihmEndDoesNotExistTest()
	{
		//testing what is returned if the destination node does not exist
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		try 
		{
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
			ug.addEdge("A", "B");
			ug.addEdge("B", "C");
		}
		catch(VertexExistsException e)
		{
			e.printStackTrace();
		}
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "B", "E");
		List<String> expected = new ArrayList<String>();
		assertEquals(result, expected);
	}
	
	@Test
	public void algorithmStartEqualEndTest()
	{
		//testing what we return if the start and end are equal
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		try 
		{
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
			ug.addEdge("A", "B");
			ug.addEdge("B", "C");
		}
		catch(VertexExistsException e)
		{
			e.printStackTrace();
		}
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "B", "B");
		List<String> expected = new ArrayList<String>();
		expected.add("B");
		assertEquals(result, expected);
	}
	
	@Test
	public void algorithmBFSTest1()
	{
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		try {
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
			ug.addVertex("D");
			ug.addVertex("E");
			ug.addVertex("F");
			ug.addEdge("A", "B");
			ug.addEdge("A", "C");
			ug.addEdge("B", "D");
			ug.addEdge("C", "D");
			ug.addEdge("C", "E");
			ug.addEdge("D", "E");
			ug.addEdge("E", "F");
		} catch (VertexExistsException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "A", "F");
		List<String> expected = new ArrayList<>();
		expected.add("A");
		expected.add("C");
		expected.add("E");
		expected.add("F");
		assertEquals(result, expected);
	}
	
	@Test
	public void algorithmBFSTest()
	{
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
		try {
			ug.addVertex("A");
			ug.addVertex("B");
			ug.addVertex("C");
			ug.addVertex("D");
			ug.addVertex("E");
			ug.addVertex("F");
			ug.addEdge("A", "B");
			ug.addEdge("A", "C");
			ug.addEdge("A", "D");
			ug.addEdge("B", "D");
			ug.addEdge("C", "D");
			ug.addEdge("C", "E");
			ug.addEdge("C", "B");
			ug.addEdge("D", "E");
			ug.addEdge("E", "F");
		} catch (VertexExistsException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		List<String> result = (ArrayList<String>) uga.findBFSpath(ug, "A", "F");
		List<String> expected = new ArrayList<>();
		expected.add("A");
		expected.add("C");
		expected.add("E");
		expected.add("F");
		assertEquals(result, expected);
	}
	
	@Test
	public void algorithmOneNodeInGraphTest()
	{
		//testing what happens when there is only one node in the graph
		UndirectedGraph<String> ug = new UndirectedGraph<>();;
	}
}
